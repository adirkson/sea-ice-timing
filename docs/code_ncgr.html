
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>NCGR &#8212; sea-ice-timing 1.0.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Using the dcnorm module" href="Examples/DCNORM_distribution_example.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="ncgr">
<h1>NCGR<a class="headerlink" href="#ncgr" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>ncgr<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-ncgr"></span><p>Created on Tue Feb 25 15:55:31 2020</p>
<p>&#64;author: arlan</p>
<dl class="class">
<dt id="ncgr.ncgr_fullfield">
<em class="property">class </em><code class="sig-prename descclassname">ncgr.</code><code class="sig-name descname">ncgr_fullfield</code><span class="sig-paren">(</span><em class="sig-param">fcst_netcdf</em>, <em class="sig-param">hc_netcdf</em>, <em class="sig-param">obs_netcdf</em>, <em class="sig-param">out_netcdf</em>, <em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">model_dict</em>, <em class="sig-param">obs_dict</em>, <em class="sig-param">clim_netcdf=None</em>, <em class="sig-param">terc_interp=None</em>, <em class="sig-param">sigma_eqn='s3'</em>, <em class="sig-param">es_tol=0.05</em>, <em class="sig-param">pred_pval=0.05</em>, <em class="sig-param">options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_fullfield" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>Performs non-homogeneous censored gaussian regression (NCGR) [1]
on a forecast ice-free date (IFD) or freeze-up date (FUD) field using input
NetCDF files.</p></li>
<li><p>An output NetCDF file is created that contains several quantities relevant to calibration.</p></li>
</ul>
<dl>
<dt>Args:</dt><dd><dl>
<dt>fcst_netcdf (str):</dt><dd><p>Path of the NetCDF file containing the ensemble forecast IFDs or FUDs to be calibrated. 
Requirements for the file are as follows:</p>
<ul class="simple">
<li><p>The structure/shape of the IFD/FUD variable should be: 
(time, ensemble members, latitude, longitude), although the actual names of those dimensions 
and corresponding variables (if they are included in the NetCDF files) can be anything.</p></li>
<li><p>Relevant variable names and dimension names are to be specified by the user with the 
<code class="docutils literal notranslate"><span class="pre">model_dict</span></code> argument provided to this function.</p></li>
<li><p>The variable for the time coordinate, which should represent the forecast initialization date,
should follow CF conventions (<a class="reference external" href="https://cfconventions.org/">https://cfconventions.org/</a>).
In particular, it’s necessary for the initialization year be retrievable from the time 
variable using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">netCDF4.num2date()</span></code> function (<a class="reference external" href="https://unidata.github.io/netcdf4-python/netCDF4/index.html">https://unidata.github.io/netcdf4-python/netCDF4/index.html</a>).</p></li>
<li><p>Masked locations will be ignored in calibration and will be written as masked locations
in the output NetCDF file.</p></li>
</ul>
</dd>
<dt>hc_netcdf (str):</dt><dd><p>Path of the NetCDF file
containing the model ensemble forecast IFDs or FUDs used to train NCGR. This file should
contain several years of model re-forecasts (hindcasts), and may in fact include data for years after the 
year of the forecast being calibrated (e.g. if leave-one-out cross-validation is being performed).
The requirements for the file are the same as for <code class="docutils literal notranslate"><span class="pre">fcst_netcdf</span></code>, except that the variable corresponding
to the time coordinate should contain several dates (i.e. the initialization date for each forecast).</p>
</dd>
<dt>obs_netcdf (str):</dt><dd><p>Path of the NetCDF file
containing the observed IFDs or FUDs used to train NCGR. This file should
contain several years of observed IFDs/FUDs (corresponding to what was verified for
the model hindcasts in <code class="docutils literal notranslate"><span class="pre">hc_netcdf</span></code>). Requirements for the file are as follows:</p>
<ul class="simple">
<li><p>Relevant variable names and dimension names are to be specified by the user with the 
<code class="docutils literal notranslate"><span class="pre">obs_dict</span></code> argument provided to this function.</p></li>
<li><p>The structure/shape of the IFD/FUD variable should be: 
(time, latitude, longitude), although the actual names of those dimensions 
and corresponding variables (if they are included in the NetCDF files) can be anything.</p></li>
<li><p>The variable for the time coordinate, which should represent the initialization dates of the re-forecasts
in <code class="docutils literal notranslate"><span class="pre">hc_netcdf</span></code>, should follow CF conventions (<a class="reference external" href="https://cfconventions.org/">https://cfconventions.org/</a>).
In particular, it’s necessary for the initialization year be retrievable from the time 
variable using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">netCDF4.num2date()</span></code> function (<a class="reference external" href="https://unidata.github.io/netcdf4-python/netCDF4/index.html">https://unidata.github.io/netcdf4-python/netCDF4/index.html</a>).</p></li>
<li><p>Masked locations will be ignored in calibration and will be written as masked locations
in the output NetCDF file.</p></li>
</ul>
</dd>
<dt>out_netcdf (str):</dt><dd><p>The absolute path of the NetCDF file to
be written that contains relevant calibrated forecast quantities. For more information on this file
see <a class="reference internal" href="#ncgr.ncgr_fullfield.write_output" title="ncgr.ncgr_fullfield.write_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ncgr_fullfield.write_output()</span></code></a>.</p>
</dd>
<dt>a (float or int):</dt><dd><p>Minimum possible date for the event in 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). See definition 
in [1]. IFDs or FUDs provided in input NetCDF files should be
set to the value provided to <code class="docutils literal notranslate"><span class="pre">a</span></code> when the event has occurred at the time
of forecast initialization.</p>
</dd>
<dt>b (float or int):</dt><dd><p>Maximum possible date for the event in 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). See definition 
in [1]. IFDs or FUDs provided in input NetCDF files should be
set to the value provided to <code class="docutils literal notranslate"><span class="pre">b</span></code> when the event does not occur by the end
of the season.</p>
</dd>
<dt>model_dict (tuple(dict,dict)):</dt><dd><p>A tuple of two dictionaries. The first specifies the
relevant variables in the NetCDF files 
assigned to <code class="docutils literal notranslate"><span class="pre">fcst_netcdf</span></code> and <code class="docutils literal notranslate"><span class="pre">hc_netcdf</span></code>. The second specifies the
relevant demension names in those same files</p>
<p>For the first dictionary, its keys (which must follow the naming conventions used below) 
and values (specified by user) are:</p>
<blockquote>
<div><p>‘event_vn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Variable name for the ice-free date or freeze-up date field(s)</p>
<p>‘time_vn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Variable name for the forecast initialization date</p>
</div></blockquote>
<p>For the second dictionary, its keys (which must follow the naming conventions used below) 
and values (specified by user) are:</p>
<blockquote>
<div><p>‘time_dn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Dimension name for the forecast initialization date</p>
<p>‘ens_dn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Dimension name for the forecast realization/ensemble member</p>
</div></blockquote>
<dl>
<dt>Example:</dt><dd><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model_dict</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;event_vn&#39;</span> <span class="p">:</span> <span class="s1">&#39;ifd&#39;</span><span class="p">,</span>
               <span class="s1">&#39;time_vn&#39;</span> <span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span>
              <span class="p">{</span><span class="s1">&#39;time_dn&#39;</span> <span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
               <span class="s1">&#39;ens_dn&#39;</span> <span class="p">:</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">})</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>obs_dict (tuple(dict,dict)):</dt><dd><p>A tuple of two dictionaries. The first specifies the
relevant variables in the NetCDF file
assigned to <code class="docutils literal notranslate"><span class="pre">obs_netcdf</span></code>. The second specifies the
relevant demension names in that same file.</p>
<p>For the first dictionary, its keys (which must follow the naming conventions used below) 
and values (specified by user) are:</p>
<blockquote>
<div><p>‘event_vn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Variable name for ice-free date or freeze-up date field(s)</p>
<p>‘time_vn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Variable name for the forecast initialization date</p>
</div></blockquote>
<p>For the second dictionary, its keys (which must follow the naming conventions used below) 
and values (specified by user) are:</p>
<blockquote>
<div><p>‘time_dn’: <code class="docutils literal notranslate"><span class="pre">str</span></code>: Dimension name for the forecast initialization date</p>
</div></blockquote>
<dl>
<dt>Example:</dt><dd><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">obs_dict</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;event_vn&#39;</span> <span class="p">:</span> <span class="s1">&#39;ifd&#39;</span><span class="p">,</span> 
               <span class="s1">&#39;time_vn&#39;</span> <span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span>
              <span class="p">{</span><span class="s1">&#39;time_dn&#39;</span> <span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">})</span> 
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>clim_netcdf (str, optional):</dt><dd><p>The absolute path of the NetCDF file that contains several years of observed IFDs or FUDs
used to construct the climatology that forecast IFDs/FUDs will be in
reference to. If this is included, forecast probabilities for each the 
early, near-normal, and late events, as well as ensemble-mean anomalies are 
included in the <code class="docutils literal notranslate"><span class="pre">out_netcdf</span></code> file. Requirements for this file are the same as those
for <code class="docutils literal notranslate"><span class="pre">obs_netcdf</span></code>.</p>
</dd>
<dt>terc_interp (str or None, optional):</dt><dd><p>Interpolation scheme used to compute the terciles for the observed climatology. Default is None.
Can be one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>None: By default y_clim data are fit to the DCNORM distribution,</p></li>
</ul>
<p>and terciles are computed using its <code class="xref py py-meth docutils literal notranslate"><span class="pre">_ppf()</span></code> method.</p>
<ul class="simple">
<li><p>‘HD’: Estimate terciles using the Harrell-Davis estimator (see :py:class:scipy.stats.mstats.hdquantiles)</p></li>
<li><p>‘nearest-rank’: Nearest rank or rank order method (see</p></li>
</ul>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Percentile#The_nearest-rank_method">https://en.wikipedia.org/wiki/Percentile#The_nearest-rank_method</a>)</p>
<ul class="simple">
<li><p>Any of the interpolation arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.percentile</span></code>.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>sigma_eqn (str, optional): </dt><dd><p>Refers to the regression equation to be used for the <span class="math notranslate nohighlight">\(\sigma\)</span>
parameter in the NCGR model. This can be one of ‘s1’, ‘s2’, or ‘s3’.
These are defined by the regression equations below as <span class="math notranslate nohighlight">\(\sigma_{I}\)</span>,
<span class="math notranslate nohighlight">\(\sigma_{II}\)</span>, and <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>, respectively. By default,
<code class="docutils literal notranslate"><span class="pre">sigma_eqn='s3'</span></code> (i.e. <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>).</p>
</dd>
<dt>es_tol (float or None, optional):</dt><dd><p>Early stopping threshold used for minimizing the CRPS. 
By default <code class="docutils literal notranslate"><span class="pre">es_tol=0.05</span></code>. Specifically, this argument
sets the <code class="docutils literal notranslate"><span class="pre">tol</span></code> argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.optimize.minimize(method=’SLSQP’)</span></code>.</p>
</dd>
<dt>pred_pval (float, optional):</dt><dd><p>The p-value for determining statistical significance of the second 
predictor for the  <span class="math notranslate nohighlight">\(\sigma_{II}\)</span> or <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>
regression equations. By default, <code class="docutils literal notranslate"><span class="pre">pred_pval=0.05</span></code>.</p>
</dd>
<dt>options (dict, optional): </dt><dd><p>A dictionary of options to pass to :py:method:’scipy.optimize.minimize’ corresponding to 
its <code class="docutils literal notranslate"><span class="pre">options</span></code> argument (see <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.optimize.minimize(method=’SLSQP’)</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
<p>The following provides a brief description of NCGR; for a full description, see [1].</p>
<p>NCGR assumes the observed IFD or FUD, <span class="math notranslate nohighlight">\(Y(t)\)</span> (a random variable), conditioned
on the ensemble forecast <span class="math notranslate nohighlight">\(x_1(t),...,x_n(t)\)</span> follows a DCNORM distribution –
i.e. <span class="math notranslate nohighlight">\(Y(t)|x_1(t),...,x_n(t)\sim N_{dc}(\mu(t),\sigma(t))\)</span>. The parameter <span class="math notranslate nohighlight">\(\mu\)</span>
is modelled as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mu(t) = \alpha_1\mu_{c}(t) + \alpha_2 x_{\langle i \rangle}^{d}(t)\]</div>
</div></blockquote>
<p>The user can choose one of the following equations for modelling the paremter <span class="math notranslate nohighlight">\(\sigma\)</span></p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\sigma_{I}(t) &amp;=\beta_1\sigma_{c}, \\ 
\sigma_{II}(t) &amp;=\beta_1\sigma_{c}+\beta_2 s_x(t), \\ 
\sigma_{III}(t) &amp;=\beta_1\sigma_{c}+\beta_2 x_{\langle i \rangle}^{tc}(t)\end{split}\]</div>
</div></blockquote>
<p>through the <code class="docutils literal notranslate"><span class="pre">sigma</span></code> argument, but by default <span class="math notranslate nohighlight">\(\sigma=\sigma_{III}\)</span>.</p>
<p>The relevant methods contained in this class are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">calibrate_fullfield()</span></code></dt><dd><p>Performs NCGR on the forecast IFD or FUD field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_output()</span></code></dt><dd><p>Creates a NetCDF file containing several relevant fields to the 
NCGR-calibrated forecast.</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p>Dirkson, A.​, B. Denis., M.,Sigmond., &amp; Merryfield, W.J. (2020). Development and Calibration of SeasonalProbabilistic Forecasts of Ice-free Dates and Freeze-up Dates. ​Weather and Forecasting​. doi:10.1175/WAF-D-20-0066.1.</p>
</dd>
</dl>
<dl class="method">
<dt id="ncgr.ncgr_fullfield.calibrate_fullfield">
<code class="sig-name descname">calibrate_fullfield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_fullfield.calibrate_fullfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Loops through the spatial grid and performs NCGR
at each grid point.</p>
<dl>
<dt>Returns:</dt><dd><dl>
<dt>result (ndarray object):</dt><dd><p>An object array. If <code class="docutils literal notranslate"><span class="pre">clim_netcdf</span></code> is included as an argument to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ncgr_fullfield</span></code></a>,
<code class="docutils literal notranslate"><span class="pre">results</span></code> is an object containing six arrays corresponding to the following variables:</p>
<blockquote>
<div><dl class="simple">
<dt>mu_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\mu\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> is the number of rows and
<cite>ncol</cite> is the number of columns provided as spatial coordinates
in the NetCDF files given to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ncgr_fullfield</span></code></a>.</p>
</dd>
<dt>sigma_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\sigma\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>fcst_probs (ndarray), shape (<cite>3</cite>, <cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The three forecast probabilities for early, near-normal, and late
sea-ice retreat/advance, where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>fcst_pre (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The probability for the pre-occurrence of the event.</p>
</dd>
<dt>fcst_non (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The probability for the non-occurrence of the event.</p>
</dd>
<dt>clim_terc (ndarray), shape (<cite>2</cite>, <cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The two terciles (i.e. 1/3 and 2/3 quantiles) for the observed climatology,
where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>mean (float):</dt><dd><p>Expected value of the forecast DCNORM distribution.</p>
</dd>
<dt>mean_anom (float):</dt><dd><p>Anomaly of <code class="docutils literal notranslate"><span class="pre">mean</span></code> relative to climatology.</p>
</dd>
</dl>
</div></blockquote>
<p>If climatology is not included as an argument to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ncgr_fullfield</span></code></a>, <code class="docutils literal notranslate"><span class="pre">results</span></code> contains two
arrays corresponding to the following variables:</p>
<blockquote>
<div><dl class="simple">
<dt>mu_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\mu\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> is the number of rows and
<cite>ncol</cite> is the number of columns provided as spatial coordinates
in the NetCDF files given to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ncgr_fullfield</span></code></a>.</p>
</dd>
<dt>sigma_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\sigma\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>fcst_pre (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The probability for the pre-occurrence of the event.</p>
</dd>
<dt>fcst_non (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The probability for the non-occurrence of the event.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.ncgr_fullfield.write_output">
<code class="sig-name descname">write_output</code><span class="sig-paren">(</span><em class="sig-param">result</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_fullfield.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the variables provided as arguments to this function to the NetCDF file <code class="docutils literal notranslate"><span class="pre">out_netcdf</span></code>,
an argument provided to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ncgr_fullfield</span></code></a>. Note that this will remove and replace any previous version of 
<code class="docutils literal notranslate"><span class="pre">out_netcdf</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mu_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\mu\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> is the number of rows and
<cite>ncol</cite> is the number of columns provided as spatial coordinates
in the NetCDF files given to <a class="reference internal" href="#ncgr.ncgr_fullfield" title="ncgr.ncgr_fullfield"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ncgr_fullfield()</span></code></a>.</p>
</dd>
<dt>sigma_cal (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Calibrated <span class="math notranslate nohighlight">\(\sigma\)</span> parameter for the predictive 
DCNORM distribution, where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>fcst_probs (ndarray), shape (<cite>3</cite>, <cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The three forecast probabilities for early, near-normal, and late
sea-ice retreat/advance, where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>fcst_pre (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Probability for the pre-occurrence of the event.</p>
</dd>
<dt>fcst_non (ndarray), shape (<cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>Probability for the non-occurrence of the event.</p>
</dd>
<dt>clim_terc (ndarray), shape (<cite>2</cite>, <cite>nrow</cite>, <cite>ncol</cite>):</dt><dd><p>The two terciles (i.e. 1/3 and 2/3 quantiles) for the observed climatology,
where <cite>nrow</cite> and <cite>ncol</cite> are defined as
in <code class="docutils literal notranslate"><span class="pre">mu_cal</span></code>.</p>
</dd>
<dt>ens_mean (float):</dt><dd><p>Expected value of the forecast DCNORM distribution.</p>
</dd>
<dt>ens_mean_anom (float):</dt><dd><p>Anomaly of <code class="docutils literal notranslate"><span class="pre">ens_mean</span></code> relative to the climatological mean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="ncgr.ncgr_gridpoint">
<em class="property">class </em><code class="sig-prename descclassname">ncgr.</code><code class="sig-name descname">ncgr_gridpoint</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_gridpoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>a (float or int):</dt><dd><p>Minimum possible date for the event in 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). See definition 
in [1]. IFDs or FUDs provided in input NetCDF files should be
set to the value provided to <code class="docutils literal notranslate"><span class="pre">a</span></code> when the event has occurred at the time
of forecast initialization.</p>
</dd>
<dt>b (float or int):</dt><dd><p>Maximum possible date for the event in 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). See definition 
in [1]. IFDs or FUDs provided in input NetCDF files should be
set to the value provided to <code class="docutils literal notranslate"><span class="pre">b</span></code> when the event does not occur by the end
of the season.</p>
</dd>
</dl>
<p>The following provides a brief description of NCGR; for a full description, see <a href="#id6"><span class="problematic" id="id3">[1]_</span></a>.</p>
<p>NCGR assumes the observed IFD or FUD, <span class="math notranslate nohighlight">\(Y(t)\)</span> (a random variable), conditioned
on the ensemble forecast <span class="math notranslate nohighlight">\(x_1(t),...,x_n(t)\)</span> follows a DCNORM distribution –
i.e. <span class="math notranslate nohighlight">\(Y(t)|x_1(t),...,x_n(t)\sim N_{dc}(\mu(t),\sigma(t))\)</span>. The parameter <span class="math notranslate nohighlight">\(\mu\)</span>
is modelled as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mu(t) = lpha_1\mu_{c}(t) + lpha_2 x_{\langle i \]</div>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>angle}^{d}(t)</p>
<blockquote>
<div><p>The user can choose one of the following equations for modelling the paremter <span class="math notranslate nohighlight">\(\sigma\)</span></p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sigma_{I}(t) &amp;=eta_1\sigma_{c}, \ 
\sigma_{II}(t) &amp;=eta_1\sigma_{c}+eta_2 s_x(t), \ 
\sigma_{III}(t) &amp;=eta_1\sigma_{c}+eta_2 x_{\langle i \]</div>
</div></blockquote>
</div></blockquote>
<p>angle}^{tc}(t)</p>
<blockquote>
<div><p>through the <code class="docutils literal notranslate"><span class="pre">sigma</span></code> argument, but by default <span class="math notranslate nohighlight">\(\sigma=\sigma_{III}\)</span>.</p>
<p>The relevant method contained in this class is:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">calibrate_gridpoint()</span></code></dt><dd><p>Performs NCGR on the forecast IFD or FUD at a single gridpoint.</p>
</dd>
</dl>
<p>%(after_notes)s</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets">1</span></dt>
<dd><p>Dirkson, A.​, B. Denis., M.,Sigmond., &amp; Merryfield, W.J. (2020). Development and Calibration of SeasonalProbabilistic Forecasts of Ice-free Dates and Freeze-up Dates. ​Weather and Forecasting​. doi:10.1175/WAF-D-20-0066.1.</p>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="ncgr.ncgr_gridpoint.build_model">
<code class="sig-name descname">build_model</code><span class="sig-paren">(</span><em class="sig-param">X_t</em>, <em class="sig-param">X</em>, <em class="sig-param">Y</em>, <em class="sig-param">tau_t</em>, <em class="sig-param">t</em>, <em class="sig-param">sigma_eqn='s3'</em>, <em class="sig-param">pred_pval=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_gridpoint.build_model" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>X_t (ndarray), shape (<cite>n,</cite>):</dt><dd><p>Forecast to be calibrated, where <cite>n</cite> is the ensemble size.</p>
</dd>
<dt>X (ndarray), shape (<cite>N,n</cite>):</dt><dd><p>Forecasts for training NCGR, where <cite>N</cite> is the number of years
for training and <cite>n</cite> is the ensemble size for a 
given forecast.</p>
</dd>
<dt>Y (ndarray), shape (<cite>N,</cite>):</dt><dd><p>Observations for training NCGR, where <cite>N</cite> is the number of years
for training.</p>
</dd>
<dt>tau_t (ndarray), shape (<cite>N,</cite>):</dt><dd><p>Years corresponding to those used for training period (this should not
contain the forecast year). The year should be based on the initialization 
date, not the date of the IFD or FUD event.</p>
</dd>
<dt>t (float or int):</dt><dd><p>The year in which the forecast is initialized.</p>
</dd>
<dt>sigma_eqn (str, optional): </dt><dd><p>Refers to the regression equation to be used for the <span class="math notranslate nohighlight">\(\sigma\)</span>
parameter in the NCGR model. This can be one of ‘s1’, ‘s2’, or ‘s3’.
These are defined by the regression equations below as <span class="math notranslate nohighlight">\(\sigma_{I}\)</span>,
<span class="math notranslate nohighlight">\(\sigma_{II}\)</span>, and <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>, respectively. By default,
<code class="docutils literal notranslate"><span class="pre">sigma='s3'</span></code> (i.e. <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>).</p>
</dd>
<dt>pred_pval (float, optional):</dt><dd><p>The p-value for determining statistical significance of the second 
predictor for the  <span class="math notranslate nohighlight">\(\sigma_{II}\)</span> or <span class="math notranslate nohighlight">\(\sigma_{III}\)</span>
regression equations. By default, <code class="docutils literal notranslate"><span class="pre">pred_pval=0.05</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>predictors_tau (ndarray or ndarray object), shape (2,2,N) or (2,)</dt><dd><p>Contains the predictors for both mu and sigma over the training 
period. It’s an object
if mu and sigma have different numbers of predictors (i.e. when
there is no second term in the equation for sigma). It’s an array
if mu and sigma have the same number of predictors. Regardless, the 
following is always true for the first two entries:</p>
<dl class="simple">
<dt>predictors_tau[0] (ndarray), shape (2, N):</dt><dd><p>The predictors for mu over the training period</p>
</dd>
<dt>predictors_tau[1] (ndarray), shape (1, N) or (2, N):</dt><dd><p>The predictor(s) for sigma over the training period</p>
</dd>
</dl>
</dd>
<dt>predictors_t (ndarray or object array), shape (2,2) or shape (2,)</dt><dd><p>Contains the predictors for both mu and sigma for the forecast year
t. It’s an object
if mu and sigma have different numbers of predictors (i.e. when
there is no second term in the equation for sigma). It’s an array
if mu and sigma have the same number of predictors. Regardless, the 
following is always true for the first two entries:</p>
<dl class="simple">
<dt>predictors_tau[0] (ndarray), shape (2,):</dt><dd><p>The predictors for mu for the forecast year t</p>
</dd>
<dt>predictors_tau[1] (ndarray), shape (1,) or (2,):</dt><dd><p>The predictor(s) for sigma for the forecast year t</p>
</dd>
</dl>
</dd>
<dt>coeffs0 (array), shape (3,) or (4,):</dt><dd><p>Initial guesses for the coefficients in the NCGR regression equations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.ncgr_gridpoint.optimizer">
<code class="sig-name descname">optimizer</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">predictors_tau</em>, <em class="sig-param">coeffs0</em>, <em class="sig-param">es_tol=0.05</em>, <em class="sig-param">options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.ncgr_gridpoint.optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for minimizing the CRPS over N forecasts. For this, 
<code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.optimize.minimize(method=’SLSQP’)</span></code> is called to 
minimize the analytic expression for the CRPS when the distribution under
consideration for the forecast is the DCNORM distribution.</p>
<dl class="simple">
<dt>Args:                 </dt><dd><dl class="simple">
<dt>Y (ndarray), shape (<cite>N,</cite>):</dt><dd><p>Observations for training NCGR, where <cite>N</cite> is the number of years
for training.</p>
</dd>
<dt>predictors_tau (ndarray or object of ndarray), shape (<cite>2,</cite>) or (<cite>2,4,N</cite>)</dt><dd><p>Predictors over the training period. If an object of ndarray, then
<cite>predictors_tau[0]</cite> has shape (<cite>2,N</cite>) corresponding to predictors for
<span class="math notranslate nohighlight">\(mu\)</span>, and <cite>predictors_tau[1]</cite> has shape
(<cite>N,</cite>) corresponding to the single predictor for <span class="math notranslate nohighlight">\(sigma\)</span>.</p>
</dd>
<dt>coeffs0 (array), shape (3,) or (4,):</dt><dd><p>Initial guesses for the coefficients in the NCGR regression equations.</p>
</dd>
<dt>es_tol (float or None, optional):</dt><dd><p>Early stopping threshold used for minimizing the CRPS. 
By default <code class="docutils literal notranslate"><span class="pre">es_tol=0.05</span></code>. Specifically, this argument
sets the <code class="docutils literal notranslate"><span class="pre">tol</span></code> argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.optimize.minimize(method=’SLSQP’)</span></code>.</p>
</dd>
<dt>options (dict, optional): </dt><dd><p>A dictionary of options to pass to :py:method:’scipy.optimize.minimize’ corresponding to 
its <code class="docutils literal notranslate"><span class="pre">options</span></code> argument (see <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.optimize.minimize(method=’SLSQP’)</span></code>).</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>coeffs (array):</dt><dd><p>Optimized regression coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="ncgr.crps_funcs">
<em class="property">class </em><code class="sig-prename descclassname">ncgr.</code><code class="sig-name descname">crps_funcs</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains functions needed to perform CRPS minimization for the DCNORM distribution.
It also contains a function for computing the CRPS when the forecast distribution
takes the form of a DCNORM distribution (as it does for NCGR).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a (float or int):</dt><dd><p>Minimum possible date for the event in non leap year
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). A value
larger than 365 is regarded as a date for the following year.</p>
</dd>
<dt>b (float or int):</dt><dd><p>Maximum possible date for the event in non leap year 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). A value
larger than 365 is regarded as a date for the following year. The 
<code class="docutils literal notranslate"><span class="pre">b</span></code> argument must be larger than the <code class="docutils literal notranslate"><span class="pre">a</span></code> argument.</p>
</dd>
</dl>
</dd>
</dl>
<p>The methods contained in this class are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">crps_dcnorm()</span></code></dt><dd><p>Computes the CRPS for a set of forecsts and observations
when the predictive distribution takes the form of a 
DCNORM distribution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crps_ncgr()</span></code></dt><dd><p>The cost function used when executing <code class="docutils literal notranslate"><span class="pre">scipy.optimize.mimize</span></code>
in the <code class="docutils literal notranslate"><span class="pre">calibrate</span></code> method. Computes the mean CRPS as a function of a set
of hindcast CDFs (modelled by NCGR) and observed dates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crps_ncgr_jac()</span></code></dt><dd><p>Called on in the <code class="docutils literal notranslate"><span class="pre">calibrate</span></code> method. 
Computes the jacobian matrix for the CRPS cost function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crps_singleyear()</span></code></dt><dd><p>Called on in the <code class="docutils literal notranslate"><span class="pre">calibrate</span></code> method. 
Computes the CRPS for a single forecast CDF (modelled as a DCNORM
distribution) and observation.</p>
</dd>
</dl>
<dl class="method">
<dt id="ncgr.crps_funcs.crps_dcnorm">
<code class="sig-name descname">crps_dcnorm</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">mu</em>, <em class="sig-param">sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs.crps_dcnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Time mean continuous rank probability score (CRPS) when the distribution
takes the form of a DCNORM distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>y (ndarray), shape (<cite>n</cite>,):</dt><dd><p>Observed dates, where <cite>n</cite> is the number of
forecast/observation pairs.</p>
</dd>
<dt>mu (ndarray), shape (<cite>n</cite>,):</dt><dd><p>DCNORM parameter <span class="math notranslate nohighlight">\(\mu\)</span> for each of the <cite>1,…,n</cite> forecast distributions.</p>
</dd>
<dt>sigma (ndarray), shape (<cite>n</cite>,):</dt><dd><p>DCNORM parameter <span class="math notranslate nohighlight">\(\sigma\)</span> for each of the <cite>1,…,n</cite> forecast distributions.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>result (float):</dt><dd><p>Time mean CRPS.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.crps_funcs.crps_dcnorm_single">
<code class="sig-name descname">crps_dcnorm_single</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">mu</em>, <em class="sig-param">sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs.crps_dcnorm_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Continuous rank probability score (CRPS) for a single forecast when the distribution
takes the form of a DCNORM distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>y (float or int):</dt><dd><p>Observed date.</p>
</dd>
<dt>mu (float or int):</dt><dd><p>DCNORM parameter <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
</dd>
<dt>sigma (float or int):</dt><dd><p>DCNORM parameter <span class="math notranslate nohighlight">\(\sigma\)</span></p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>result (float):</dt><dd><p>CRPS</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.crps_funcs.crps_ncgr">
<code class="sig-name descname">crps_ncgr</code><span class="sig-paren">(</span><em class="sig-param">coeffs</em>, <em class="sig-param">predictors</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs.crps_ncgr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:            </dt><dd><dl class="simple">
<dt>coeffs (list), shape (<cite>m</cite>,):</dt><dd><p>Coefficients in the NCGR regression equations, 
where <cite>m</cite> is the total number of coefficients/predictors. The first two values
correspond to those for <span class="math notranslate nohighlight">\(\mu\)</span> and the remaining values
correspond to those for <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</dd>
<dt>predictors (object), shape (<cite>n</cite>,):</dt><dd><p>Object containing the predictors, where <cite>n=2</cite> is the number of distribution parameters.
The shape of either predictors[0] or predictors[1] is (<cite>m,p</cite>), where
<cite>m</cite> is the number of coefficients/predictors for the corresponding parameter, and <cite>p</cite> is the number of
years in the training period <code class="docutils literal notranslate"><span class="pre">self.tau_t</span></code>.</p>
</dd>
<dt>y (ndarray), shape (<cite>p</cite>,):</dt><dd><p>Array of observed dates, where <cite>p</cite> is the number of
years in the training period <code class="docutils literal notranslate"><span class="pre">self.tau_t</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The time-averaged continuous rank probability score (CRPS).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.crps_funcs.crps_ncgr_jac">
<code class="sig-name descname">crps_ncgr_jac</code><span class="sig-paren">(</span><em class="sig-param">coeffs</em>, <em class="sig-param">predictors</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs.crps_ncgr_jac" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>coeffs (list), shape (<cite>n+m</cite>):</dt><dd><p>Coefficients in the NCGR regression equations, 
where <cite>n=2</cite> is the number of distribution parameters 
and <cite>m</cite> is the number of predictors for a given parameter. The first
two values are the coefficients for <span class="math notranslate nohighlight">\(\mu\)</span> and the 
remaining values are the coefficeints for <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</dd>
<dt>predictors (object), shape (<cite>n</cite>,):</dt><dd><p>Object containing the predictors, where <cite>n=2</cite> is the number of distribution parameters.
The shape of either predictors[0] or predictors[1] is (<cite>m,p</cite>), where
<cite>m</cite> is the number of coefficients/predictors for the corresponding parameter, and <cite>p</cite> is the number of
years in the training period <code class="docutils literal notranslate"><span class="pre">self.tau_t</span></code>.</p>
</dd>
<dt>y (ndarray), shape (<cite>p</cite>):</dt><dd><p>Array of observed dates, where <cite>p</cite> is the number of
years in the training period <code class="docutils literal notranslate"><span class="pre">self.tau_t</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>(ndarray), shape (m,):</dt><dd><p>The jacobian matrix of the time-averaged continuous rank probability score.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.crps_funcs.crps_ncgr_sy">
<code class="sig-name descname">crps_ncgr_sy</code><span class="sig-paren">(</span><em class="sig-param">params</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.crps_funcs.crps_ncgr_sy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the continuous rank probability score
for a single forecast with DCNORM distribution.</p>
<dl class="simple">
<dt>Args:     </dt><dd><dl class="simple">
<dt>params (list), shape (2,):</dt><dd><p>List containing the two DCNORM distribution parameters 
<span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</dd>
<dt>y (float):</dt><dd><p>The observation.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>result (float):</dt><dd><p>The CRPS.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="ncgr.fcst_vs_clim">
<em class="property">class </em><code class="sig-prename descclassname">ncgr.</code><code class="sig-name descname">fcst_vs_clim</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.fcst_vs_clim" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains functions for computing forecast quantities relative to observed climataology.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a (float or int):</dt><dd><p>Minimum possible date for the event in non leap year
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). A value
larger than 365 is regarded as a date for the following year.</p>
</dd>
<dt>b (float or int):</dt><dd><p>Maximum possible date for the event in non leap year 
day-of-year units; e.g. 1=Jan 1, 91=April 1, 365=Dec 31). A value
larger than 365 is regarded as a date for the following year. The 
<code class="docutils literal notranslate"><span class="pre">b</span></code> argument must be larger than the <code class="docutils literal notranslate"><span class="pre">a</span></code> argument.</p>
</dd>
<dt>fill_value (float):</dt><dd><p>The flag value given to an event probability when it doesn’t make sense to compute one; this
occurs when the climatological terciles are equal to each other, for example.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="ncgr.fcst_vs_clim.event_probs">
<code class="sig-name descname">event_probs</code><span class="sig-paren">(</span><em class="sig-param">mu</em>, <em class="sig-param">sigma</em>, <em class="sig-param">y_clim</em>, <em class="sig-param">terc_interp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.fcst_vs_clim.event_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the forecast probabilities for an early, normal, or late
event relative to some defined climatology.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mu (float):</dt><dd><p>The mu parameter for the DCNORM distribution</p>
</dd>
<dt>sigma (float):</dt><dd><p>The sigma parameter for the DCNORM distribution</p>
</dd>
<dt>y_clim (ndarray), shape (<cite>N,</cite>):</dt><dd><p>Array of climatological dates, where <cite>N</cite> is the number of dates (equiavalently years)
used to compute climatological statistics.</p>
</dd>
<dt>terc_interp (str or None, optional):</dt><dd><p>Interpolation scheme used to compute the terciles for the observed climatology. Default is None.
Can be one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>None: By default y_clim data are fit to the DCNORM distribution,</p></li>
</ul>
<p>and terciles are computed using its <code class="xref py py-meth docutils literal notranslate"><span class="pre">_ppf()</span></code> method.</p>
<ul class="simple">
<li><p>‘HD’: Estimate terciles using the Harrell-Davis estimator (see :py:class:scipy.stats.mstats.hdquantiles)</p></li>
<li><p>‘nearest-rank’: Nearest rank or rank order method (see</p></li>
</ul>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Percentile#The_nearest-rank_method">https://en.wikipedia.org/wiki/Percentile#The_nearest-rank_method</a>)</p>
<ul class="simple">
<li><p>Any of the interpolation arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.percentile</span></code>.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>result (object ndarray):</dt><dd><p>An object array containing 2 arrays. The first array has shape (3,) and contains the forecast
probabilities for being the event occuring early, near-normal, or late, respectively. The
second array has shape (2,) and contains the climatological terciles deliniating 
the event categories.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.fcst_vs_clim.fcst_deterministic">
<code class="sig-name descname">fcst_deterministic</code><span class="sig-paren">(</span><em class="sig-param">mu</em>, <em class="sig-param">sigma</em>, <em class="sig-param">y_clim</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.fcst_vs_clim.fcst_deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the calibrated forecast ensemble mean and ensemble mean anomaly
relative to climatology. Means for the forecast are calculated as the
expected value of the calibrated DCNORM distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mu (float):</dt><dd><p>The mu parameter for the DCNORM distribution</p>
</dd>
<dt>sigma (float):</dt><dd><p>The sigma parameter for the DCNORM distribution</p>
</dd>
<dt>y_clim (array):</dt><dd><p>Array of climatological dates.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>fcst_mean (float):</dt><dd><p>The expected value of the forecast DCNORM distribution round to
the nearest day.</p>
</dd>
<dt>fcst_mean_anom (float):</dt><dd><p>The anomaly of <code class="docutils literal notranslate"><span class="pre">mean</span></code> relative to the mean of <code class="docutils literal notranslate"><span class="pre">y_clim</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ncgr.fcst_vs_clim.fcst_prenon">
<code class="sig-name descname">fcst_prenon</code><span class="sig-paren">(</span><em class="sig-param">mu</em>, <em class="sig-param">sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#ncgr.fcst_vs_clim.fcst_prenon" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the probabilities for the pre-occurrence and non-occurrence of the IFD/FUD
event.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mu (float):</dt><dd><p>The mu parameter for the DCNORM distribution</p>
</dd>
<dt>sigma (float):</dt><dd><p>The sigma parameter for the DCNORM distribution</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>pre_occur (float):</dt><dd><p>Probability for the pre-occurrence of the IFD/FUD.</p>
</dd>
<dt>non_occur (float):</dt><dd><p>Probability for the pre-occurrence of the IFD/FUD.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-dcnorm">
<span id="dcnorm"></span><h2>dcnorm<a class="headerlink" href="#module-dcnorm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dcnorm.dcnorm_gen">
<em class="property">class </em><code class="sig-prename descclassname">dcnorm.</code><code class="sig-name descname">dcnorm_gen</code><span class="sig-paren">(</span><em class="sig-param">momtype=1</em>, <em class="sig-param">a=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">xtol=1e-14</em>, <em class="sig-param">badvalue=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">longname=None</em>, <em class="sig-param">shapes=None</em>, <em class="sig-param">extradoc=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dcnorm.dcnorm_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A doubly-censored normal (DCNORM) random variable, censored numerically below <span class="math notranslate nohighlight">\(a\)</span> and
above <span class="math notranslate nohighlight">\(b\)</span>.</p>
<p>The probability density function for a DCNORM random variable is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f(x;\mu,\sigma)=  \Phi\left( \frac{a-\mu}{\sigma}\right)\delta(x-a) +
            \frac{1}{\sigma}\phi\left(\frac{x-\mu}{\sigma}\right)1_{(a,b)} + 
            \left[1 - \Phi\left( \frac{b-\mu}{\sigma}\right)\right]\delta(x-b),\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(1_{(a,b)}=1\)</span> when <span class="math notranslate nohighlight">\(a&lt;x&lt;b\)</span> and <span class="math notranslate nohighlight">\(1_{(a,b)}=0\)</span> otherwise; <span class="math notranslate nohighlight">\(\delta(x)\)</span> is the delta function;
<span class="math notranslate nohighlight">\(\phi(\cdot)\)</span> and <span class="math notranslate nohighlight">\(\Phi(\cdot)\)</span> are respectively the PDf and CDF for a standard normal distribution with
zero mean and unit variance. The support is <span class="math notranslate nohighlight">\(a\leq X \leq b\)</span>, and requirements are <span class="math notranslate nohighlight">\(\infty&lt;\mu&lt;\infty\)</span> and
<span class="math notranslate nohighlight">\(\sigma&gt;0\)</span>.</p>
<p><a class="reference internal" href="#dcnorm.dcnorm_gen" title="dcnorm.dcnorm_gen"><code class="xref py py-class docutils literal notranslate"><span class="pre">dcnorm_gen</span></code></a> is an instance of a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">rv_continuous</span></code>, and therefore
inherits all of the methods within <code class="xref py py-class docutils literal notranslate"><span class="pre">rv_continuous</span></code>. Some of those methods
have been subclassed here:</p>
<p><code class="docutils literal notranslate"><span class="pre">_argcheck</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">_cdf</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">_pdf</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">_ppf</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">_stats</span></code></p>
<p>Additional methods added to <a class="reference internal" href="#module-dcnorm" title="dcnorm"><code class="xref py py-class docutils literal notranslate"><span class="pre">dcnorm</span></code></a> are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ecdf(x,</span> <span class="pre">data)</span></code></dt><dd><p>The empirical distribution function for a sample <code class="docutils literal notranslate"><span class="pre">data</span></code> at values <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fit(data)</span></code></dt><dd><p>This replaces the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method in <code class="xref py py-class docutils literal notranslate"><span class="pre">rv_continuous</span></code>. 
Computes the maximum likelihood estimates for the DCNORM distribution
parameters.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dcnorm</span> <span class="kn">import</span> <span class="n">dcnorm_gen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Set the minimum and maximum values allowed for the DCNORM distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="mi">273</span>
</pre></div>
</div>
<p>Instantiate the DCNORM distribution class with the given min/max values</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dcnorm</span> <span class="o">=</span> <span class="n">dcnorm_gen</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Variables for the <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> parameters for the DCNORM distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">=</span><span class="mf">132.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="mf">20.</span>
</pre></div>
</div>
<p>Create a distribution object (see <code class="xref py py-class docutils literal notranslate"><span class="pre">rv_continuous</span></code> for details on available methods)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rv</span> <span class="o">=</span> <span class="n">dcnorm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>As an example, create a sample of 100 random draws from this distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Now fit the sample to a DCNORM distribution (this is done using maximum likelihood (ML) estimation)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m_f</span><span class="p">,</span> <span class="n">s_f</span> <span class="o">=</span> <span class="n">dcnorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Make a new distribution object with the ML estimates computed previously</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rv_f</span> <span class="o">=</span> <span class="n">dcnorm</span><span class="p">(</span><span class="n">m_f</span><span class="p">,</span> <span class="n">s_f</span><span class="p">)</span>
</pre></div>
</div>
<p>Make range of values for plotting</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the emperical CDF for the sample <cite>X</cite>, the true distribution defined originally, and the 
distribution obtained by fitting to X.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dcnorm</span><span class="o">.</span><span class="n">ecdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;empirical CDF&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rv</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;true CDF&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rv_f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fitted CDF&#39;</span><span class="p">)</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="dcnorm.dcnorm_gen.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">m</em>, <em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#dcnorm.dcnorm_gen.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function of the given RV.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>quantiles</p>
</dd>
<dt>arg1, arg2, arg3,…<span class="classifier">array_like</span></dt><dd><p>The shape parameter(s) for the distribution (see docstring of the
instance object for more information)</p>
</dd>
<dt>loc<span class="classifier">array_like, optional</span></dt><dd><p>location parameter (default=0)</p>
</dd>
<dt>scale<span class="classifier">array_like, optional</span></dt><dd><p>scale parameter (default=1)</p>
</dd>
</dl>
<dl class="simple">
<dt>cdf<span class="classifier">ndarray</span></dt><dd><p>Cumulative distribution function evaluated at <cite>x</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dcnorm.dcnorm_gen.ecdf">
<code class="sig-name descname">ecdf</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#dcnorm.dcnorm_gen.ecdf" title="Permalink to this definition">¶</a></dt>
<dd><p>For computing the empirical cumulative distribution function (ecdf) of a
given sample.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>x (float or ndarray):</dt><dd><p>The value(s) at which the ecdf is evaluated</p>
</dd>
<dt>data (float or ndarray):</dt><dd><p>A sample for which to compute the ecdf.</p>
</dd>
</dl>
</dd>
<dt>Returns: ecdf_vals (ndarray):            </dt><dd><p>The ecdf for X_samp, evaluated at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dcnorm.dcnorm_gen.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#dcnorm.dcnorm_gen.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return MLEs for shape (if applicable), location, and scale
parameters from data.</p>
<p>MLE stands for Maximum Likelihood Estimate.  Starting estimates for
the fit are given by input arguments; for any arguments not provided
with starting estimates, <code class="docutils literal notranslate"><span class="pre">self._fitstart(data)</span></code> is called to generate
such.</p>
<p>One can hold some parameters fixed to specific values by passing in
keyword arguments <code class="docutils literal notranslate"><span class="pre">f0</span></code>, <code class="docutils literal notranslate"><span class="pre">f1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">fn</span></code> (for shape parameters)
and <code class="docutils literal notranslate"><span class="pre">floc</span></code> and <code class="docutils literal notranslate"><span class="pre">fscale</span></code> (for location and scale parameters,
respectively).</p>
<dl class="simple">
<dt>data<span class="classifier">array_like</span></dt><dd><p>Data to use in calculating the MLEs.</p>
</dd>
<dt>args<span class="classifier">floats, optional</span></dt><dd><p>Starting value(s) for any shape-characterizing arguments (those not
provided will be determined by a call to <code class="docutils literal notranslate"><span class="pre">_fitstart(data)</span></code>).
No default value.</p>
</dd>
<dt>kwds<span class="classifier">floats, optional</span></dt><dd><p>Starting values for the location and scale parameters; no default.
Special keyword arguments are recognized as holding certain
parameters fixed:</p>
<ul class="simple">
<li><p>f0…fn : hold respective shape parameters fixed.
Alternatively, shape parameters to fix can be specified by name.
For example, if <code class="docutils literal notranslate"><span class="pre">self.shapes</span> <span class="pre">==</span> <span class="pre">&quot;a,</span> <span class="pre">b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">fa``and</span> <span class="pre">``fix_a</span></code>
are equivalent to <code class="docutils literal notranslate"><span class="pre">f0</span></code>, and <code class="docutils literal notranslate"><span class="pre">fb</span></code> and <code class="docutils literal notranslate"><span class="pre">fix_b</span></code> are
equivalent to <code class="docutils literal notranslate"><span class="pre">f1</span></code>.</p></li>
<li><p>floc : hold location parameter fixed to specified value.</p></li>
<li><p>fscale : hold scale parameter fixed to specified value.</p></li>
<li><p>optimizer : The optimizer to use.  The optimizer must take <code class="docutils literal notranslate"><span class="pre">func</span></code>,
and starting position as the first two arguments,
plus <code class="docutils literal notranslate"><span class="pre">args</span></code> (for extra arguments to pass to the
function to be optimized) and <code class="docutils literal notranslate"><span class="pre">disp=0</span></code> to suppress
output as keyword arguments.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>mle_tuple<span class="classifier">tuple of floats</span></dt><dd><p>MLEs for any shape parameters (if applicable), followed by those
for location and scale. For most random variables, shape statistics
will be returned, but there are exceptions (e.g. <code class="docutils literal notranslate"><span class="pre">norm</span></code>).</p>
</dd>
</dl>
<p>This fit is computed by maximizing a log-likelihood function, with
penalty applied for samples outside of range of the distribution. The
returned answer is not guaranteed to be the globally optimal MLE, it
may only be locally optimal, or the optimization may fail altogether.
If the data contain any of np.nan, np.inf, or -np.inf, the fit routine
will throw a RuntimeError.</p>
<p>Generate some data to fit: draw random variates from the <cite>beta</cite>
distribution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">beta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">beta</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can fit all four parameters (<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span> <span class="o">=</span> <span class="n">beta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also use some prior knowledge about the dataset: let’s keep
<code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> fixed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span> <span class="o">=</span> <span class="n">beta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fscale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
<p>We can also keep shape parameters fixed by using <code class="docutils literal notranslate"><span class="pre">f</span></code>-keywords. To
keep the zero-th shape parameter <code class="docutils literal notranslate"><span class="pre">a</span></code> equal 1, use <code class="docutils literal notranslate"><span class="pre">f0=1</span></code> or,
equivalently, <code class="docutils literal notranslate"><span class="pre">fa=1</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span> <span class="o">=</span> <span class="n">beta</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fa</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fscale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Not all distributions return estimates for the shape parameters.
<code class="docutils literal notranslate"><span class="pre">norm</span></code> for example just returns estimates for location and scale:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc1</span><span class="p">,</span> <span class="n">scale1</span>
<span class="go">(0.92087172783841631, 2.0015750750324668)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sitdates">
<span id="sitdates"></span><h2>sitdates<a class="headerlink" href="#module-sitdates" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Jan 28 10:56:59 2019</p>
<p>&#64;author: arlan</p>
<dl class="class">
<dt id="sitdates.sitdates">
<em class="property">class </em><code class="sig-prename descclassname">sitdates.</code><code class="sig-name descname">sitdates</code><span class="sig-paren">(</span><em class="sig-param">event</em>, <em class="sig-param">min_dates=None</em>, <em class="sig-param">max_dates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates" title="Permalink to this definition">¶</a></dt>
<dd><p>This module contains several functions that are useful for setting and getting minimium and 
maximum possible dates, and for converting between day-of-year and date formats
for plotting.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>event (str) {‘ifd’,’fud’}:</dt><dd><p>Can be either ‘ifd’ or ‘fud’.</p>
</dd>
<dt>min_dates (array, optional), shape=(12,):</dt><dd><p>If provided, this array defines the minimum date (<span class="math notranslate nohighlight">\(a\)</span> value)
allowed for the ice-free date or freeze-up date for each calendar month corresponding to
the initialization month.
If not provided, then <code class="xref py py-data docutils literal notranslate"><span class="pre">time_functions.min_dates</span></code>
will be set to the values used in [1]. To only change
a subset of those dates from [1], rather than including this argument it may be faster to 
use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_min_date()</span></code> function.</p>
</dd>
<dt>max_dates (array, optional), shape=(12,):</dt><dd><p>If provided, this array defines the maximum date (<span class="math notranslate nohighlight">\(b\)</span> value)
allowed for the ice-free date or freeze-up date for each calendar month corresponding to
the initialization month.
If not provided, then <code class="xref py py-data docutils literal notranslate"><span class="pre">time_functions.min_dates</span></code>
will be set to the values used in [1]. To only change
a subset of those dates from [1], rather than including this argument it may be faster to 
use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_min_date()</span></code> function.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">1</span></dt>
<dd><p>To be filled in with reference following publication.</p>
</dd>
</dl>
<dl class="method">
<dt id="sitdates.sitdates.date_to_doy">
<code class="sig-name descname">date_to_doy</code><span class="sig-paren">(</span><em class="sig-param">date</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.date_to_doy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute date in day-of-year format for a given date.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>date (object):</dt><dd><p>A ‘’date object’’ made with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.date()</span></code> function
(see: <a class="reference external" href="https://docs.python.org/3/library/datetime.html#date-objects">https://docs.python.org/3/library/datetime.html#date-objects</a>).</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Day-of-year value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.dates_to_doys">
<code class="sig-name descname">dates_to_doys</code><span class="sig-paren">(</span><em class="sig-param">dates</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.dates_to_doys" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dates in day-of-year format for a given list of dates.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dates (list):</dt><dd><p>A list of ‘’date objects’’ made with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.date()</span></code> function
(see: <a class="reference external" href="https://docs.python.org/3/library/datetime.html#date-objects">https://docs.python.org/3/library/datetime.html#date-objects</a>).</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>List of days-of-year values</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.doy_to_date">
<code class="sig-name descname">doy_to_date</code><span class="sig-paren">(</span><em class="sig-param">doy</em>, <em class="sig-param">format='%m/%d'</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.doy_to_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a date for a given day-of-year value.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>doy (int or float):</dt><dd><p>Day-of-year value</p>
</dd>
<dt>format (optional, ‘str’):</dt><dd><p>An acceptable format given to <code class="xref py py-meth docutils literal notranslate"><span class="pre">strftime()</span></code> (default=’%m%d’;
see: <a class="reference external" href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a>)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Day of year integer</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.get_max">
<code class="sig-name descname">get_max</code><span class="sig-paren">(</span><em class="sig-param">month</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.get_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the maximum possible ice-free/freeze-up date for a given initialization month.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>month (int or array(N,dtype=’int’)):</dt><dd><p>Value(s) between 1 and 12 corresponding to the calendar month(s) for which the maximum
date is to be returned.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Day of year or days of year representing the maximum possible date for <code class="docutils literal notranslate"><span class="pre">month</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.get_min">
<code class="sig-name descname">get_min</code><span class="sig-paren">(</span><em class="sig-param">month</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.get_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the minimum possible ice-free/freeze-up date for a given initialization month.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>month (int or array(N,dtype=’int’)):</dt><dd><p>Value(s) between 1 and 12 corresponding to the calendar month(s) for which the minimum
date is to be returned.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Day of year or days of year representing the maximum possible date for <code class="docutils literal notranslate"><span class="pre">month</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.set_max">
<code class="sig-name descname">set_max</code><span class="sig-paren">(</span><em class="sig-param">month</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.set_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Override pre-existing maximum date value(s) in <code class="xref py py-data docutils literal notranslate"><span class="pre">time_functions.min_dates</span></code> array.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>month (int or array(N,dtype=’int’)):</dt><dd><p>Value(s) between 1 and 12 corresponding to the calendar month(s) for which the maximum
date is to be overriden.</p>
</dd>
<dt>value (int, float, or array(N,)):</dt><dd><p>The date(s) in day-of-year format that will override the pre-existing maximum date(s)
for the calendar month(s) provided in the <code class="docutils literal notranslate"><span class="pre">month</span></code> argument.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sitdates.sitdates.set_min">
<code class="sig-name descname">set_min</code><span class="sig-paren">(</span><em class="sig-param">month</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#sitdates.sitdates.set_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Override pre-existing minimum date value(s) in <code class="xref py py-data docutils literal notranslate"><span class="pre">time_functions.min_dates</span></code> array.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>month (int or array(N,dtype=’int’)):</dt><dd><p>Value(s) between 1 and 12 corresponding to the calendar month(s) for which the minimum
date is to be overriden.</p>
</dd>
<dt>value (int, float, or array(N,)):</dt><dd><p>The date(s) in day-of-year format that will override the pre-existing minimum date(s)
for the calendar month(s) provided in the <code class="docutils literal notranslate"><span class="pre">month</span></code> argument.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">sea-ice-timing</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Examples/NCGR_fullfield_example.html">Performing NCGR on a full forecast field</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Examples/NCGR_fullfield_example.html">Performing NCGR on a full forecast field</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples/NCGR_gridpoint_example.html">Performing NCGR at a gridpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples/DCNORM_distribution_example.html">Using the dcnorm module</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">NCGR</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">ncgr</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-dcnorm">dcnorm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sitdates">sitdates</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Examples/DCNORM_distribution_example.html" title="previous chapter">Using the dcnorm module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Arlan Dirkson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/code_ncgr.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>